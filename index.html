<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>中国皇帝时间轴查询</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --muted: #94a3b8; /* slate-400 */
      --text: #e5e7eb; /* gray-200 */
      --accent: #22c55e; /* green-500 */
      --accent-2: #60a5fa; /* blue-400 */
      --warn: #f59e0b; /* amber-500 */
      --danger: #ef4444; /* red-500 */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent-2); }
    header { padding: 24px 16px 8px; max-width: 1100px; margin: 0 auto; }
    h1 { margin: 0 0 8px; font-size: 28px; letter-spacing: .3px; }
    .sub { color: var(--muted); font-size: 14px; }

    .card { max-width: 1100px; margin: 16px auto; background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); border: 1px solid rgba(148,163,184,.2); border-radius: 16px; padding: 16px; }

    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .row > * { flex: 0 0 auto; }
    input[type="text"] {
      width: min(460px, 90vw);
      padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(148,163,184,.25);
      background: #0b1220; color: var(--text); outline: none;
    }
    input[type="text"]::placeholder { color: #64748b; }

    .radio { display: inline-flex; gap: 6px; align-items: center; color: var(--muted); font-size: 14px; }
    .btn {
      padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(148,163,184,.25);
      background: var(--accent-2); color: #0b1220; font-weight: 600; cursor: pointer;
    }
    .btn.secondary { background: transparent; color: var(--text); }

    .status { margin-top: 8px; color: var(--muted); font-size: 13px; }

    #timeline-wrap { width: 100%; overflow-x: auto; }
    svg { width: 100%; height: auto; display: block; }
    .axis text { fill: var(--muted); font-size: 12px; }
    .axis line, .axis path { stroke: rgba(148,163,184,.25); }
    .bar { fill: var(--accent-2); opacity: .9; }
    .bar.focus { fill: var(--accent); }
    .bar-outline { stroke: rgba(255,255,255,.6); stroke-width: .5; fill: none; }
    .label { fill: var(--text); font-size: 12px; }
    .legend { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .pill { display:inline-block; padding:2px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,.25); margin-right:6px; }

    details { margin-top: 8px; }
    summary { cursor: pointer; color: var(--muted); }

    .footer { max-width: 1100px; margin: 14px auto 30px; color: var(--muted); font-size: 12px; padding: 0 16px; }
  </style>
  <!-- SheetJS (XLSX) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <header>
    <h1>中国皇帝时间轴查询</h1>
    <div class="sub">把 <code>emperors.xlsx</code> 和本页面一起放到仓库根目录（或同一文件夹）
      ，开启 GitHub Pages 即可在线查询。表头需包括：<strong>朝代、姓名、常用称呼、庙号、谥号、在位起、在位止、额外在位</strong>（最后一列可选）。</div>
  </header>

  <section class="card">
    <div class="row">
      <input id="q" type="text" placeholder="输入朝代名或皇帝姓名，例如：汉、隋唐、刘洵、赵匡胤…" list="suggestions" />
      <datalist id="suggestions"></datalist>
      <label class="radio"><input type="radio" name="mode" value="dynasty" checked>按朝代</label>
      <label class="radio"><input type="radio" name="mode" value="name">按姓名</label>
      <button class="btn" id="btnSearch">查询</button>
      <button class="btn secondary" id="btnReset">重置</button>
    </div>
    <div class="status" id="status">正在加载数据…</div>
  </section>

  <section class="card" id="result" style="display:none">
    <div id="summary" class="legend"></div>
    <div id="timeline-wrap"><svg id="timeline" role="img" aria-label="在位时间轴"></svg></div>
    <details><summary>表格视图（点开查看）</summary>
      <div id="table"></div>
    </details>
  </section>

  <div class="footer">数据解析在浏览器本地完成。若要更换数据文件名，请在下方脚本中修改 <code>XLSX_URL</code> 常量。</div>

<script>
  // === 可配置：数据文件名（与 index.html 同目录） ===
  const XLSX_URL = 'emperors.xlsx';

  // === 工具函数 ===
  const S = (sel, el=document) => el.querySelector(sel);
  const SS = (sel, el=document) => [...el.querySelectorAll(sel)];

  function parseNum(v) {
    if (v === undefined || v === null || v === '') return null;
    // 允许形如 "前221" / "-221" / "221 BCE" / "公元前221" 等
    const s = String(v).trim();
    if (/^公元?前/.test(s) || /^前/.test(s)) return -Number(s.replace(/[^0-9.]/g, ''));
    if (/BCE/i.test(s)) return -Number(s.replace(/[^0-9.]/g, ''));
    const n = Number(s.replace(/[^\-0-9.]/g, ''));
    return isNaN(n) ? null : n;
  }
  function yearLabel(y) {
    if (y === 0) return '公元0年';
    if (y == null) return '';
    return y < 0 ? `公元前${-y}年` : `公元${y}年`;
  }
  function niceStep(range) {
    // 计算轴刻度步长（10/20/50/100…）
    const raw = range / 8; // 目标大约 8 个刻度
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const candidates = [1, 2, 5, 10].map(k => k * pow10);
    let best = candidates[0];
    for (const c of candidates) if (Math.abs(raw - c) < Math.abs(raw - best)) best = c;
    return Math.max(1, Math.round(best));
  }

  // === 全局数据 ===
  let rows = []; // 原始数据
  let dynasties = new Set();
  let names = new Set();

  async function loadXLSX() {
    try {
      const resp = await fetch(XLSX_URL);
      if (!resp.ok) throw new Error('无法加载 ' + XLSX_URL);
      const buf = await resp.arrayBuffer();
      const wb = XLSX.read(buf, { type: 'array' });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(ws, { raw: true, defval: '' });
      // 统一字段名
      rows = json.map(r => ({
        朝代: r['朝代'] ?? r['dynasty'] ?? r['朝代名'] ?? '',
        姓名: r['姓名'] ?? r['name'] ?? '',
        常用称呼: r['常用称呼'] ?? r['称呼'] ?? r['别名'] ?? '',
        庙号: r['庙号'] ?? r['廟號'] ?? '',
        谥号: r['谥号'] ?? r['諡號'] ?? r['谥'] ?? '',
        在位起: parseNum(r['在位起'] ?? r['start'] ?? r['起'] ?? ''),
        在位止: parseNum(r['在位止'] ?? r['end'] ?? r['止'] ?? ''),
        额外在位: r['额外在位'] ?? r['extra'] ?? ''
      })).filter(r => r.朝代 && r.姓名);

      rows.forEach(r => { dynasties.add(r.朝代); names.add(r.姓名); if (r.常用称呼) names.add(r.常用称呼); });
      fillSuggestions();
      S('#status').textContent = `已加载 ${rows.length} 条记录。可按朝代或姓名查询。`;
    } catch (e) {
      console.error(e);
      S('#status').innerHTML = `<span style="color:var(--danger)">数据加载失败：</span>${e.message}。请确认 <code>${XLSX_URL}</code> 与本页面在同一目录，且 GitHub Pages 允许跨域访问同仓库静态资源。`;
    }
  }

  function fillSuggestions() {
    const dl = S('#suggestions');
    dl.innerHTML = '';
    [...dynasties].sort().slice(0,300).forEach(d => {
      const o = document.createElement('option'); o.value = d; dl.appendChild(o);
    });
    [...names].sort().slice(0,300).forEach(n => { const o = document.createElement('option'); o.value = n; dl.appendChild(o); });
  }

  function search() {
    const q = S('#q').value.trim();
    const mode = S('input[name="mode"]:checked').value; // dynasty | name
    if (!q) { S('#status').textContent = '请输入要查询的朝代或姓名'; return; }

    if (mode === 'dynasty') {
      const list = rows.filter(r => r.朝代.includes(q));
      if (!list.length) { S('#status').textContent = `未找到与 “${q}” 匹配的朝代`; S('#result').style.display='none'; return; }
      drawTimeline(list, null, `按朝代检索：${q}（${list.length} 位皇帝）`);
    } else {
      // 姓名：找出该人物所在朝代，并把该朝代全部画出，并高亮该人物
      let person = rows.find(r => r.姓名.includes(q) || (r.常用称呼 && r.常用称呼.includes(q)));
      if (!person) { S('#status').textContent = `未找到姓名包含 “${q}” 的记录`; S('#result').style.display='none'; return; }
      const list = rows.filter(r => r.朝代 === person.朝代);
      drawTimeline(list, q, `按姓名检索：${q}（所属朝代：${person.朝代}，共 ${list.length} 位）`);
    }
  }

  function drawTimeline(list, focusName=null, summary='') {
    // 过滤掉没年份的
    const valid = list.filter(r => r.在位起 != null && r.在位止 != null);
    if (!valid.length) { S('#status').textContent = '该查询下没有完整年份的数据。'; S('#result').style.display='none'; return; }

    // 按起年排序
    valid.sort((a,b) => (a.在位起 ?? 0) - (b.在位起 ?? 0));

    const minYear = Math.min(...valid.map(r => r.在位起));
    const maxYear = Math.max(...valid.map(r => r.在位止));
    const range = Math.max(1, maxYear - minYear);

    const wrap = S('#timeline-wrap');
    const W = Math.max(900, wrap.clientWidth - 2); // 最小 900，保证刻度可读
    const leftPad = 120, rightPad = 24, topPad = 24, rowH = 28, gap = 8;
    const H = topPad + (rowH + gap) * valid.length + 40;

    const scale = y => leftPad + ( (y - minYear) / range ) * (W - leftPad - rightPad);

    // 生成 SVG
    const svg = S('#timeline');
    svg.setAttribute('width', W);
    svg.setAttribute('height', H);
    svg.innerHTML = '';

    // 轴线
    const axisY = topPad + (rowH + gap) * valid.length + 10;
    const axisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    axisLine.setAttribute('x1', leftPad); axisLine.setAttribute('x2', W - rightPad);
    axisLine.setAttribute('y1', axisY); axisLine.setAttribute('y2', axisY);
    axisLine.setAttribute('stroke', 'rgba(148,163,184,.35)');
    svg.appendChild(axisLine);

    // 刻度
    const step = niceStep(range);
    const startTick = Math.ceil(minYear / step) * step;
    for (let t = startTick; t <= maxYear; t += step) {
      const x = scale(t);
      const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      tick.setAttribute('x1', x); tick.setAttribute('x2', x);
      tick.setAttribute('y1', axisY); tick.setAttribute('y2', axisY + 6);
      tick.setAttribute('stroke', 'rgba(148,163,184,.5)');
      svg.appendChild(tick);

      const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      lbl.setAttribute('x', x); lbl.setAttribute('y', axisY + 18);
      lbl.setAttribute('text-anchor', 'middle'); lbl.setAttribute('class', 'axis');
      lbl.textContent = t < 0 ? `前${-t}` : `${t}`;
      svg.appendChild(lbl);
    }

    // 每人一行
    valid.forEach((r, i) => {
      const y = topPad + i * (rowH + gap);
      const x1 = scale(r.在位起), x2 = scale(r.在位止);
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

      // 左侧标签（姓名 + 庙号/谥号）
      const name = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      name.setAttribute('x', leftPad - 8); name.setAttribute('y', y + rowH * 0.68);
      name.setAttribute('text-anchor', 'end'); name.setAttribute('class', 'label');
      const display = r.常用称呼 || r.姓名;
      const extra = [r.庙号, r.谥号].filter(Boolean).join(' ');
      name.textContent = extra ? `${display}（${extra}）` : display;
      g.appendChild(name);

      // 在位条
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', Math.min(x1, x2));
      rect.setAttribute('y', y);
      rect.setAttribute('width', Math.max(4, Math.abs(x2 - x1)));
      rect.setAttribute('height', rowH);
      rect.setAttribute('rx', 6);
      rect.setAttribute('class', 'bar' + (focusName && (r.姓名.includes(focusName) || (r.常用称呼 && r.常用称呼.includes(focusName))) ? ' focus' : ''));
      g.appendChild(rect);

      const outline = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      outline.setAttribute('x', Math.min(x1, x2));
      outline.setAttribute('y', y);
      outline.setAttribute('width', Math.max(4, Math.abs(x2 - x1)));
      outline.setAttribute('height', rowH);
      outline.setAttribute('rx', 6);
      outline.setAttribute('class', 'bar-outline');
      g.appendChild(outline);

      // tooltip（原生 <title> 即可）
      const tip = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      tip.textContent = `${r.朝代}·${r.姓名}${r.常用称呼?`（${r.常用称呼}）`:''}
${yearLabel(r.在位起)} — ${yearLabel(r.在位止)}`;
      g.appendChild(tip);

      svg.appendChild(g);
    });

    S('#summary').innerHTML = `<span class="pill">范围：${yearLabel(minYear)} 至 ${yearLabel(maxYear)}</span>` +
      (focusName ? `<span class="pill" style="border-color:var(--accent); color:var(--accent)">高亮：${focusName}</span>` : '') +
      ` <span class="pill">共 ${valid.length} 位</span> <span class="pill">${summary}</span>`;

    // 表格视图
    renderTable(valid);

    S('#result').style.display = '';
    S('#status').textContent = '查询完成（可滚动/缩放浏览）。';
  }

  function renderTable(list) {
    const tbl = document.createElement('table');
    tbl.style.width = '100%';
    tbl.style.borderCollapse = 'collapse';
    const fields = ['朝代','姓名','常用称呼','庙号','谥号','在位起','在位止','额外在位'];
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    fields.forEach(h => { const th = document.createElement('th'); th.textContent = h; th.style.textAlign='left'; th.style.borderBottom='1px solid rgba(148,163,184,.25)'; th.style.padding='6px 4px'; th.style.color='var(--muted)'; hr.appendChild(th); });
    thead.appendChild(hr); tbl.appendChild(thead);

    const tbody = document.createElement('tbody');
    list.forEach(r => {
      const tr = document.createElement('tr');
      fields.forEach(f => { const td = document.createElement('td'); let v = r[f]; if (f==='在位起' || f==='在位止') v = yearLabel(r[f]); td.textContent = v ?? ''; td.style.padding='6px 4px'; td.style.borderBottom='1px dashed rgba(148,163,184,.15)'; tr.appendChild(td); });
      tbody.appendChild(tr);
    });
    tbl.appendChild(tbody);

    const wrap = S('#table');
    wrap.innerHTML=''; wrap.appendChild(tbl);
  }

  // === 事件 ===
  S('#btnSearch').addEventListener('click', search);
  S('#btnReset').addEventListener('click', () => { S('#q').value=''; S('#result').style.display='none'; S('#status').textContent = '已重置。'; });
  S('#q').addEventListener('keydown', e => { if (e.key==='Enter') search(); });

  // === 启动 ===
  loadXLSX();
</script>
</body>
</html>
