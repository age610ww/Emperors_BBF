<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>皇帝时间轴（多朝代可选 · 滚轮缩放 · 横向滚动）</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<style>
.axis-tick{position:absolute;top:0;bottom:0;width:1px;background:#e5e7eb}
.axis-label{position:absolute;top:100%;transform:translateX(-50%);font-size:10px;color:#6b7280;white-space:nowrap}
.bar{height:12px;border-radius:9999px;opacity:.95}
.label{font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.handle{cursor:grab}
.badge{background:#eef2ff;border:1px solid #c7d2fe;color:#3730a3;padding:2px 6px;border-radius:999px;font-size:12px}
</style>
</head>
<body class="bg-neutral-50 text-neutral-800">
<main class="max-w-6xl mx-auto p-4 sm:p-6 space-y-6">
<header class="flex flex-col sm:flex-row sm:items-end sm:justify-between gap-3">
  <div>
    <h1 class="text-2xl sm:text-3xl font-bold">皇帝时间轴</h1>
    <p class="text-neutral-500">下拉选择要展示的朝代并「添加」。支持鼠标滚轮缩放（以鼠标位置为中心），底部横向滚动条平移；外部年份刻度会随缩放自适应（最小间隔 1 年）。</p>
  </div>
  <div class="flex gap-2">
    <button id="reloadBtn" class="px-3 py-2 rounded-md border bg-white">重新读取 XLSX</button>
    <button id="exportJsonBtn" class="px-3 py-2 rounded-md bg-black text-white">导出 JSON</button>
  </div>
</header>

<section class="bg-white border rounded-xl p-4 space-y-3">
  <div class="grid sm:grid-cols-3 gap-3 items-end">
    <div>
      <label class="text-sm text-neutral-600">选择朝代（或“全部”）</label>
      <select id="dynSelect" class="mt-1 w-full px-3 py-2 border rounded-lg"></select>
    </div>
    <div class="flex gap-2">
      <button id="addDyn" class="px-3 py-2 rounded-md bg-blue-600 text-white w-full">添加到时间轴</button>
      <button id="clearDyn" class="px-3 py-2 rounded-md border bg-white w-full">清空</button>
    </div>
    <div>
      <label class="text-sm text-neutral-600">搜索人物（可选）</label>
      <input id="q" class="mt-1 w-full px-3 py-2 border rounded-lg" placeholder="输入姓名/常用称呼/庙号/谥号…用于过滤已展示朝代"/>
    </div>
  </div>
  <div id="activeDyns" class="flex flex-wrap gap-2"></div>
</section>

<section class="bg-white border rounded-xl p-5 space-y-2">
  <div class="text-sm text-neutral-500">外部刻度（年份）：</div>
  <div id="axisWrap" class="border rounded-md overflow-x-auto bg-white">
    <div id="axis" class="relative h-8 min-w-full"></div>
  </div>

  <div class="text-lg font-semibold mt-2">时间轴（滚轮缩放；底部横向滚动条平移）</div>
  <div class="border rounded-lg overflow-x:auto overflow-y:auto">
    <div class="grid" style="grid-template-columns:200px 1fr;min-height:260px;">
      <div class="bg-neutral-50 border-r">
        <div class="h-10 flex items-center px-3 text-xs text-neutral-500 border-b">朝代（可拖拽排序）</div>
        <div id="dynList" class="max-h-96 overflow-y-auto"></div>
      </div>
      <div class="relative">
        <div id="tracksWrap" class="max-h-96 overflow-auto bg-neutral-50">
          <div id="tracksCanvas" class="relative"></div>
        </div>
      </div>
    </div>
  </div>
</section>

<footer class="text-xs text-neutral-400 py-8">© 多朝代选择 · 滚轮缩放 · 自适应刻度 · 横向滚动</footer>
</main>

<script>
(function(){
  const S = {
    rows:[], dynData:[], order:[], collapsed:{},
    global:{min:0,max:1,span:1},
    scale:4, // px per year（会随缩放变化）
    minScale:2, maxScale:200,
    selected:new Set(), // 选中的朝代集合
  };
  const $=s=>document.querySelector(s);
  const dynList=$('#dynList'), tracksWrap=$('#tracksWrap'), canvas=$('#tracksCanvas');
  const axisWrap=$('#axisWrap'), axis=$('#axis'), qInput=$('#q'), activeDyns=$('#activeDyns'), dynSelect=$('#dynSelect');
  const palette=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];

  // ===== 解析与工具 =====
  function parseYM(v){
    if(v==null) return; const t=String(v).trim(); if(!t) return;
    let m=t.match(/^([+\-]?\d{1,5})\s*(?:[\/.年\-–—]\s*(\d{1,2}))?\s*(?:月)?$/);
    if(m){ const y=parseInt(m[1],10); const mo=m[2]?Math.max(1,Math.min(12,parseInt(m[2],10))):undefined; return {y,m:mo}; }
    let m2=t.match(/^公元前\s*(\d{1,5})(?:[年\-\/.]\s*(\d{1,2}))?/);
    if(m2){ const y=-parseInt(m2[1],10); const mo=m2[2]?Math.max(1,Math.min(12,parseInt(m2[2],10))):undefined; return {y,m:mo}; }
  }
  const ymToFloat=ym=> ym? ym.y + (ym.m? (ym.m-1)/12 : 0) : undefined;
  const fmtYM=ym=>!ym?'?':(ym.y<0?(ym.m?`公元前${Math.abs(ym.y)}-${String(ym.m).padStart(2,'0')}`:`公元前${Math.abs(ym.y)}`):(ym.m?`${ym.y}-${String(ym.m).padStart(2,'0')}`:String(ym.y)));
  const H=s=>String(s||'').trim();

  // ===== 数据读取与归一化 =====
  async function loadXLSX(){
    const res=await fetch('./emperors.xlsx?ts='+Date.now(),{cache:'no-store'});
    if(!res.ok){ alert('未找到 emperors.xlsx'); return; }
    const buf=await res.arrayBuffer();
    const wb=XLSX.read(buf,{type:'array'});
    const rows=[];
    wb.SheetNames.forEach(n=>{
      const ws=wb.Sheets[n]; if(!ws) return;
      const list=XLSX.utils.sheet_to_json(ws,{defval:'',raw:true});
      list.forEach(r=>rows.push(r));
    });
    S.rows=rows;
    normalize();
    initDynSelect();
    renderAll();
  }

  function normalize(){
    const map=new Map();
    for(const r of S.rows){
      const dynasty=H(r['朝代']), emperor=H(r['姓名']); if(!dynasty && !emperor) continue;
      const alias=H(r['常用称呼']), temple=H(r['庙号']), posthumous=H(r['谥号']), notes=H(r['纪年时间']);
      const s=parseYM(r['在位起']), e=parseYM(r['在位止']); if(!s && !e) continue;
      (map.get(dynasty) || map.set(dynasty,[]).get(dynasty)).push({
        dynasty, emperor, alias, temple, posthumous, notes, sYM:s, eYM:e, sF:ymToFloat(s||e), eF:ymToFloat(e||s)
      });
    }
    const dyns=[...map.keys()].sort((a,b)=>a.localeCompare(b,'zh-Hans-CN-u-co-pinyin'));
    let ci=0;
    S.dynData=dyns.map(d=>{
      const color=palette[(ci++)%palette.length];
      const items=map.get(d).sort((a,b)=>a.sF-b.sF);
      // 贪心装箱避免重叠
      const lanes=[]; items.forEach(it=>{
        let placed=false;
        for(const ln of lanes){
          if(ln[ln.length-1].eF <= it.sF){ ln.push(it); placed=true; break; }
        }
        if(!placed) lanes.push([it]);
        it._laneIndex=lanes.length-1;
      });
      const min=Math.min(...items.map(x=>x.sF));
      const max=Math.max(...items.map(x=>x.eF));
      return {dynasty:d,color,items,lanesCount:lanes.length,min,max};
    });
    const nums=[]; S.dynData.forEach(p=>{nums.push(p.min,p.max);});
    S.global.min=Math.min(...nums); S.global.max=Math.max(...nums); S.global.span=S.global.max-S.global.min;
    if(!S.order.length) S.order=S.dynData.map(x=>x.dynasty);
  }

  // ===== UI：朝代下拉 + 选择集合 =====
  function initDynSelect(){
    dynSelect.innerHTML='';
    const optAll=document.createElement('option'); optAll.value='__ALL__'; optAll.textContent='全部（添加所有朝代）'; dynSelect.appendChild(optAll);
    S.dynData.forEach(d=>{
      const o=document.createElement('option'); o.value=d.dynasty; o.textContent=d.dynasty; dynSelect.appendChild(o);
    });
    renderActiveDynChips();
  }
  function renderActiveDynChips(){
    activeDyns.innerHTML='';
    if(!S.selected.size){
      const tip=document.createElement('span'); tip.className='text-xs text-neutral-500';
      tip.textContent='当前未选择任何朝代，请从上方下拉中选择并点击“添加到时间轴”。';
      activeDyns.appendChild(tip);
      return;
    }
    [...S.selected].forEach(name=>{
      const d=S.dynData.find(x=>x.dynasty===name); if(!d) return;
      const chip=document.createElement('span'); chip.className='badge flex items-center gap-2';
      chip.style.borderColor=d.color; chip.style.color='#111827'; chip.style.background='#fff';
      chip.innerHTML=`<span class="inline-block w-2 h-2 rounded-full" style="background:${d.color}"></span>${d.dynasty}<button class="ml-1 text-xs text-neutral-500 hover:text-red-600" aria-label="remove">✕</button>`;
      chip.querySelector('button').onclick=()=>{S.selected.delete(name); renderAll();};
      activeDyns.appendChild(chip);
    });
  }

  // ===== 映射：年 -> 像素 =====
  function worldWidth(){ return Math.max(1, Math.ceil(S.global.span*S.scale)); }
  function xOf(year){ return Math.round((year - S.global.min)*S.scale); }
  function yearOf(px){ return px / S.scale + S.global.min; }

  // ===== 刻度（最小 1 年） =====
  function stepFor(pxSpan){
    // 根据像素密度决定步长，最小 1 年
    const targetPx=80; // 期望相邻刻度像素
    const rawYears=pxSpan/targetPx;
    const steps=[1,2,5,10,20,50,100,200,500,1000,2000];
    for(const s of steps){ if(s>=rawYears) return Math.max(1,s); }
    return 2000;
  }

  function renderAxis(){
    axis.style.width = worldWidth()+'px';
    axis.innerHTML='';
    const viewPx = tracksWrap.clientWidth;
    const spanPx = worldWidth();
    const step = stepFor(viewPx);
    const startYear = Math.ceil(S.global.min/step)*step;
    for(let y=startYear; y<=S.global.max; y+=step){
      const x=xOf(y);
      const t=document.createElement('div'); t.className='axis-tick'; t.style.left=x+'px';
      const lab=document.createElement('div'); lab.className='axis-label'; lab.textContent=(y<0?`公元前${Math.abs(y)}`:y);
      t.appendChild(lab); axis.appendChild(t);
    }
  }

  // ===== 主时间轴渲染（像素坐标，原生滚动） =====
  function filteredDyns(){
    const q=H(qInput.value).toLowerCase();
    const arr = S.order
      .filter(name=>S.selected.has(name))
      .map(name=>S.dynData.find(d=>d.dynasty===name))
      .filter(Boolean);
    if(!q) return arr;
    return arr.map(d=>{
      const items=d.items.filter(x=>{
        const txt=[x.alias,x.emperor,x.temple,x.posthumous,x.notes].filter(Boolean).join(' ').toLowerCase();
        return txt.includes(q);
      });
      return {...d,items,lanesCount:Math.max(1,items.reduce((mx,it)=>Math.max(mx,it._laneIndex+1),0))};
    }).filter(d=>d.items.length);
  }

  function renderTimeline(){
    // 同步轴宽度与画布宽度
    canvas.style.width = worldWidth()+'px';
    canvas.innerHTML='';
    dynList.innerHTML='';

    const list=filteredDyns();

    // 左侧排序列表（可拖拽）
    list.forEach(d=>{
      const head=document.createElement('div');
      head.className='flex items-center gap-2 px-3 py-2 border-b hover:bg-neutral-100 handle';
      const dot=document.createElement('span'); dot.className='w-2 h-2 rounded-full'; dot.style.background=d.color;
      const name=document.createElement('span'); name.textContent=d.dynasty; name.className='text-sm font-medium';
      dynList.appendChild(head); head.appendChild(dot); head.appendChild(name);
    });
    new Sortable(dynList,{
      animation:150,handle:'.handle',
      onEnd:()=>{
        const items=[...dynList.querySelectorAll('span.text-sm')].map(x=>x.textContent);
        S.order = items.concat(S.order.filter(n=>!items.includes(n))); // 已选中的保持前面顺序
        renderAll();
      }
    });

    // 右侧轨道
    let y=0;
    list.forEach(d=>{
      const track=document.createElement('div'); track.className='relative border-b bg-white';
      const laneH=18, topPad=10, bottomPad=8;
      const height = topPad + d.lanesCount*laneH + bottomPad;
      track.style.position='relative'; track.style.height=height+'px';
      track.style.transform=`translateY(${y}px)`;
      y+=height;

      // 每个条
      d.items.forEach(it=>{
        const left=xOf(it.sF), right=xOf(it.eF), width=Math.max(2, right-left);
        const top=topPad + it._laneIndex*laneH;
        const labelText=[it.alias,it.emperor].filter(Boolean).join(' ');
        const bar=document.createElement('div'); bar.className='bar absolute'; bar.style.background=d.color;
        bar.style.left=left+'px'; bar.style.top=top+'px'; bar.style.width=width+'px';
        bar.title=`${d.dynasty} · ${labelText}（${fmtYM(it.sYM)}—${fmtYM(it.eYM)}）`;
        const lab=document.createElement('div'); lab.className='label absolute'; lab.textContent=labelText;
        lab.style.left=left+'px'; lab.style.top=(top+12)+'px'; lab.style.maxWidth=Math.max(40,width+60)+'px';
        canvas.appendChild(bar); canvas.appendChild(lab);
      });

      canvas.appendChild(track);
    });

    // 设置画布总高度
    canvas.style.height = (y||60)+'px';
  }

  // ===== 缩放（滚轮，中心为鼠标位置），并同步滚动位置保持锚点不动 =====
  function attachWheelZoom(container){
    container.addEventListener('wheel',(e)=>{
      e.preventDefault();
      const rect=container.getBoundingClientRect();
      const x=e.clientX-rect.left + container.scrollLeft; // 视口内位置 + 滚动偏移 = 画布坐标
      const anchorYear = yearOf(x);

      const k=Math.exp(-e.deltaY*0.0015);
      const newScale = Math.min(S.maxScale, Math.max(S.minScale, S.scale*k));
      const ratio = newScale / S.scale;
      S.scale=newScale;

      const newX = x * ratio;
      // 调整 scrollLeft 让锚点保持在同一屏幕位置
      const screenX = e.clientX - rect.left;
      container.scrollLeft = newX - screenX;

      renderAxis(); // 刻度自适应
      renderTimeline();
      syncAxisScroll();
    }, {passive:false});
  }

  function syncAxisScroll(){
    axisWrap.scrollLeft = tracksWrap.scrollLeft;
  }

  // ===== 事件绑定 =====
  $('#reloadBtn').onclick=loadXLSX;
  $('#exportJsonBtn').onclick=()=>{
    const blob=new Blob([JSON.stringify(S.dynData,null,2)],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='emperors.json'; a.click();
  };

  // 添加/清空朝代
  $('#addDyn').onclick=()=>{
    const v=dynSelect.value;
    if(v==='__ALL__'){ S.dynData.forEach(d=>S.selected.add(d.dynasty)); }
    else if(v){ S.selected.add(v); }
    renderAll();
  };
  $('#clearDyn').onclick=()=>{ S.selected.clear(); renderAll(); };
  qInput.oninput=()=>renderAll();

  // 同步滚动
  tracksWrap.addEventListener('scroll', syncAxisScroll);

  // 初始化
  attachWheelZoom(tracksWrap);
  attachWheelZoom(axisWrap);
  loadXLSX();

  // 统一渲染入口
  function renderAll(){
    renderActiveDynChips();
    renderAxis();
    renderTimeline();
  }
})();
</script>
</body>
</html>