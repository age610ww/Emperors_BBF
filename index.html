<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>皇帝时间轴（经典版 · 无缩放）</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
.axis-tick{position:absolute;top:0;bottom:0;width:1px;background:#e5e7eb}
.axis-label{position:absolute;bottom:0;transform:translateX(-50%);font-size:11px;color:#374151;white-space:nowrap}
.bar{height:12px;border-radius:9999px;opacity:.95;position:absolute}
.label{position:absolute;left:4px;top:-16px;font-size:11px;white-space:nowrap;color:#111827;pointer-events:none}
.legend-dot{width:10px;height:10px;border-radius:9999px;display:inline-block;margin-right:8px}
.fold-btn{font-size:12px;color:#2563eb;cursor:pointer}
</style>
</head>
<body class="bg-neutral-50 text-neutral-800">
<main class="max-w-6xl mx-auto p-4 sm:p-6 space-y-5">

<header>
  <h1 class="text-2xl sm:text-3xl font-bold">皇帝时间轴（无缩放）</h1>
  <p class="text-neutral-500 text-sm">还原到最初的交互：**不支持缩放**；用底部灰色滚动条左右拖动。外部年份刻度会随滚动同步。左侧可折叠各朝代。</p>
</header>

<section class="bg-white border rounded-xl p-4 space-y-3">
  <div class="text-sm text-neutral-500">外部刻度（年份）：</div>
  <div class="border rounded-md bg-white">
    <div id="axis" class="relative h-24 w-full"></div>
  </div>

  <div class="text-lg font-semibold mt-2">时间轴（左右拖动底部灰条平移）</div>
  <div class="border rounded-lg overflow-hidden">
    <div class="grid" style="grid-template-columns:220px 1fr;">
      <div class="bg-neutral-50 border-r">
        <div class="h-10 flex items-center px-3 text-xs text-neutral-500 border-b">朝代（可折叠）</div>
        <div id="legend" class="max-h-96 overflow-y-auto"></div>
      </div>
      <div class="relative">
        <div id="tracksWrap" class="max-h-96 overflow-auto bg-neutral-50">
          <div id="canvas" class="relative"></div>
        </div>
      </div>
    </div>
  </div>
</section>

</main>

<script>
(function(){
  const S={rows:[], dynData:[], order:[], collapsed:{}, global:{min:0,max:1,span:1}, scale:4};
  const $=s=>document.querySelector(s);
  const axis=$('#axis'), wrap=$('#tracksWrap'), canvas=$('#canvas'), legend=$('#legend');
  const palette=['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];

  // 工具
  const H=s=>String(s||'').trim();
  function parseYM(v){ if(v==null) return; const t=H(v); if(!t) return;
    let m=t.match(/^([+\-]?\d{1,5})\s*(?:[\/.年\-–—]\s*(\d{1,2}))?\s*(?:月)?$/);
    if(m){ const y=parseInt(m[1],10); const mo=m[2]?Math.max(1,Math.min(12,parseInt(m[2],10))):undefined; return {y,m:mo}; }
    let m2=t.match(/^公元前\s*(\d{1,5})(?:[年\-\/.]\s*(\d{1,2}))?/);
    if(m2){ const y=-parseInt(m2[1],10); const mo=m2[2]?Math.max(1,Math.min(12,parseInt(m2[2],10))):undefined; return {y,m:mo}; }
  }
  const ymToFloat=ym=> ym? ym.y + (ym.m? (ym.m-1)/12 : 0) : undefined;
  const fmtYM=ym=>!ym?'?':(ym.y<0?(ym.m?`公元前${Math.abs(ym.y)}-${String(ym.m).padStart(2,'0')}`:`公元前${Math.abs(ym.y)}`):(ym.m?`${ym.y}-${String(ym.m).padStart(2,'0')}`:String(ym.y)));
  function xOf(year){ return Math.round((year - S.global.min)*S.scale); }
  function yearOf(px){ return px / S.scale + S.global.min; }
  function worldWidth(){ return Math.max(1, Math.ceil(S.global.span*S.scale)); }

  // 读取
  async function load(){
    const res=await fetch('./emperors.xlsx?ts='+Date.now(),{cache:'no-store'});
    if(!res.ok){ axis.innerHTML='<div class="p-3 text-sm text-red-600">未找到 emperors.xlsx</div>'; return; }
    const wb=XLSX.read(await res.arrayBuffer(),{type:'array'});
    const rows=[]; wb.SheetNames.forEach(n=>{ const ws=wb.Sheets[n]; if(ws){ XLSX.utils.sheet_to_json(ws,{defval:'',raw:true}).forEach(r=>rows.push(r)); }});
    S.rows=rows; normalize(); renderAll();
  }

  function normalize(){
    const map=new Map();
    for(const r of S.rows){
      const dynasty=H(r['朝代']), emperor=H(r['姓名']); if(!dynasty && !emperor) continue;
      const alias=H(r['常用称呼']), temple=H(r['庙号']), posthumous=H(r['谥号']), notes=H(r['纪年时间']);
      const s=parseYM(r['在位起']), e=parseYM(r['在位止']); if(!s && !e) continue;
      (map.get(dynasty) || map.set(dynasty,[]).get(dynasty)).push({
        dynasty, emperor, alias, temple, posthumous, notes, sYM:s, eYM:e, sF:ymToFloat(s||e), eF:ymToFloat(e||s)
      });
    }
    const dyns=[...map.keys()].sort((a,b)=>a.localeCompare(b,'zh-Hans-CN-u-co-pinyin'));
    let ci=0;
    S.dynData=dyns.map(d=>{
      const color=palette[(ci++)%palette.length];
      const items=map.get(d).sort((a,b)=>a.sF-b.sF);
      // 分轨避免重叠
      const lanes=[]; items.forEach(it=>{
        let placed=false;
        for(const ln of lanes){ if(ln[ln.length-1].eF <= it.sF){ ln.push(it); placed=true; break; } }
        if(!placed) lanes.push([it]);
        it._laneIndex=lanes.length-1;
      });
      const min=Math.min(...items.map(x=>x.sF));
      const max=Math.max(...items.map(x=>x.eF));
      return {dynasty:d,color,items,lanesCount:lanes.length,min,max};
    });
    const nums=[]; S.dynData.forEach(p=>{nums.push(p.min,p.max);});
    S.global.min=Math.min(...nums); S.global.max=Math.max(...nums); S.global.span=S.global.max-S.global.min;
    if(!S.order.length) S.order=S.dynData.map(x=>x.dynasty);
  }

  // 刻度（无缩放，仅跟随滚动）
  function renderAxis(){
    axis.innerHTML='';
    const viewLeft = wrap.scrollLeft;
    const viewRight = viewLeft + wrap.clientWidth;
    const y1 = yearOf(viewLeft), y2 = yearOf(viewRight);
    const visibleYears = Math.max(1e-6, y2 - y1);
    const width = axis.clientWidth;
    const steps=[1,2,5,10,20,50,100,200,500,1000,2000];
    let step = 1; for(const s of steps){ step=s; if(visibleYears/10 <= s) break; }
    const startYear = Math.floor(y1/step)*step;
    for(let y=startYear; y<=y2; y+=step){
      const x = ( (y - y1) / visibleYears ) * width;
      const tick=document.createElement('div'); tick.className='axis-tick'; tick.style.left=x+'px';
      const lab=document.createElement('div'); lab.className='axis-label'; lab.textContent=(y<0?`公元前${Math.abs(Math.round(y))}`:Math.round(y));
      tick.appendChild(lab); axis.appendChild(tick);
    }
  }

  // 渲染
  function renderTimeline(){
    canvas.style.width = worldWidth()+'px';
    canvas.innerHTML='';
    legend.innerHTML='';

    let y=0;
    S.order.forEach(name=>{
      const d=S.dynData.find(x=>x.dynasty===name); if(!d) return;
      // 左侧 legend
      const row=document.createElement('div'); row.className='flex items-center justify-between px-3 py-2 border-b';
      const left=document.createElement('div');
      left.innerHTML=`<span class="legend-dot" style="background:${d.color}"></span><span class="text-sm">${d.dynasty}</span>`;
      const btn=document.createElement('span'); btn.className='fold-btn'; btn.textContent= S.collapsed[name]?'展开':'折叠';
      btn.onclick=()=>{ S.collapsed[name]=!S.collapsed[name]; renderAll(); };
      row.appendChild(left); row.appendChild(btn); legend.appendChild(row);

      // 右侧轨道
      const track=document.createElement('div'); track.className='relative border-b bg-white';
      const laneH=20, topPad=10, bottomPad=8;
      const height = S.collapsed[name]? 18 : (topPad + d.lanesCount*laneH + bottomPad);
      track.style.height=height+'px';
      if(!S.collapsed[name]){
        d.items.forEach(it=>{
          const left=xOf(it.sF), right=xOf(it.eF), width=Math.max(2, right-left);
          const top=topPad + it._laneIndex*laneH;
          const labelText=[it.alias,it.emperor].filter(Boolean).join(' ');
          const bar=document.createElement('div'); bar.className='bar'; bar.style.background=d.color;
          bar.style.left=left+'px'; bar.style.top=top+'px'; bar.style.width=width+'px';
          bar.title=`${d.dynasty} · ${labelText}（${fmtYM(it.sYM)}—${fmtYM(it.eYM)}）`;
          const lab=document.createElement('div'); lab.className='label'; lab.textContent=labelText;
          lab.style.left=left+'px'; lab.style.top=(top-2)+'px';
          canvas.appendChild(bar); canvas.appendChild(lab);
        });
      }
      canvas.appendChild(track);
      y+=height;
    });
    canvas.style.height=(y||60)+'px';
  }

  function renderAll(){ renderTimeline(); renderAxis(); }
  wrap.addEventListener('scroll', renderAxis);

  load();
})();
</script>
</body>
</html>